// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: EntryProtocol.proto

#ifndef PROTOBUF_EntryProtocol_2eproto__INCLUDED
#define PROTOBUF_EntryProtocol_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace alibaba {
namespace otter {
namespace canal {
namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_EntryProtocol_2eproto();
void protobuf_AssignDesc_EntryProtocol_2eproto();
void protobuf_ShutdownFile_EntryProtocol_2eproto();

class Entry;
class Header;
class Column;
class RowData;
class RowChange;
class TransactionBegin;
class TransactionEnd;
class Pair;

enum EntryType {
  TRANSACTIONBEGIN = 1,
  ROWDATA = 2,
  TRANSACTIONEND = 3,
  HEARTBEAT = 4
};
bool EntryType_IsValid(int value);
const EntryType EntryType_MIN = TRANSACTIONBEGIN;
const EntryType EntryType_MAX = HEARTBEAT;
const int EntryType_ARRAYSIZE = EntryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntryType_descriptor();
inline const ::std::string& EntryType_Name(EntryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntryType_descriptor(), value);
}
inline bool EntryType_Parse(
    const ::std::string& name, EntryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntryType>(
    EntryType_descriptor(), name, value);
}
enum EventType {
  INSERT = 1,
  UPDATE = 2,
  DELETE = 3,
  CREATE = 4,
  ALTER = 5,
  ERASE = 6,
  QUERY = 7,
  TRUNCATE = 8,
  RENAME = 9,
  CINDEX = 10,
  DINDEX = 11
};
bool EventType_IsValid(int value);
const EventType EventType_MIN = INSERT;
const EventType EventType_MAX = DINDEX;
const int EventType_ARRAYSIZE = EventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EventType_descriptor();
inline const ::std::string& EventType_Name(EventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EventType_descriptor(), value);
}
inline bool EventType_Parse(
    const ::std::string& name, EventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EventType>(
    EventType_descriptor(), name, value);
}
enum Type {
  ORACLE = 1,
  MYSQL = 2,
  PGSQL = 3
};
bool Type_IsValid(int value);
const Type Type_MIN = ORACLE;
const Type Type_MAX = PGSQL;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
// ===================================================================

class Entry : public ::google::protobuf::Message {
 public:
  Entry();
  virtual ~Entry();

  Entry(const Entry& from);

  inline Entry& operator=(const Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Entry& default_instance();

  void Swap(Entry* other);

  // implements Message ----------------------------------------------

  Entry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Entry& from);
  void MergeFrom(const Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.alibaba.otter.canal.protocol.Header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::com::alibaba::otter::canal::protocol::Header& header() const;
  inline ::com::alibaba::otter::canal::protocol::Header* mutable_header();
  inline ::com::alibaba::otter::canal::protocol::Header* release_header();
  inline void set_allocated_header(::com::alibaba::otter::canal::protocol::Header* header);

  // optional .com.alibaba.otter.canal.protocol.EntryType entryType = 2 [default = ROWDATA];
  inline bool has_entrytype() const;
  inline void clear_entrytype();
  static const int kEntryTypeFieldNumber = 2;
  inline ::com::alibaba::otter::canal::protocol::EntryType entrytype() const;
  inline void set_entrytype(::com::alibaba::otter::canal::protocol::EntryType value);

  // optional bytes storeValue = 3;
  inline bool has_storevalue() const;
  inline void clear_storevalue();
  static const int kStoreValueFieldNumber = 3;
  inline const ::std::string& storevalue() const;
  inline void set_storevalue(const ::std::string& value);
  inline void set_storevalue(const char* value);
  inline void set_storevalue(const void* value, size_t size);
  inline ::std::string* mutable_storevalue();
  inline ::std::string* release_storevalue();
  inline void set_allocated_storevalue(::std::string* storevalue);

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Entry)
 private:
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_entrytype();
  inline void clear_has_entrytype();
  inline void set_has_storevalue();
  inline void clear_has_storevalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::alibaba::otter::canal::protocol::Header* header_;
  ::std::string* storevalue_;
  int entrytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static Entry* default_instance_;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  void Swap(Header* other);

  // implements Message ----------------------------------------------

  Header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 version = 1 [default = 1];
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // optional string logfileName = 2;
  inline bool has_logfilename() const;
  inline void clear_logfilename();
  static const int kLogfileNameFieldNumber = 2;
  inline const ::std::string& logfilename() const;
  inline void set_logfilename(const ::std::string& value);
  inline void set_logfilename(const char* value);
  inline void set_logfilename(const char* value, size_t size);
  inline ::std::string* mutable_logfilename();
  inline ::std::string* release_logfilename();
  inline void set_allocated_logfilename(::std::string* logfilename);

  // optional int64 logfileOffset = 3;
  inline bool has_logfileoffset() const;
  inline void clear_logfileoffset();
  static const int kLogfileOffsetFieldNumber = 3;
  inline ::google::protobuf::int64 logfileoffset() const;
  inline void set_logfileoffset(::google::protobuf::int64 value);

  // optional int64 serverId = 4;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 4;
  inline ::google::protobuf::int64 serverid() const;
  inline void set_serverid(::google::protobuf::int64 value);

  // optional string serverenCode = 5;
  inline bool has_serverencode() const;
  inline void clear_serverencode();
  static const int kServerenCodeFieldNumber = 5;
  inline const ::std::string& serverencode() const;
  inline void set_serverencode(const ::std::string& value);
  inline void set_serverencode(const char* value);
  inline void set_serverencode(const char* value, size_t size);
  inline ::std::string* mutable_serverencode();
  inline ::std::string* release_serverencode();
  inline void set_allocated_serverencode(::std::string* serverencode);

  // optional int64 executeTime = 6;
  inline bool has_executetime() const;
  inline void clear_executetime();
  static const int kExecuteTimeFieldNumber = 6;
  inline ::google::protobuf::int64 executetime() const;
  inline void set_executetime(::google::protobuf::int64 value);

  // optional .com.alibaba.otter.canal.protocol.Type sourceType = 7 [default = MYSQL];
  inline bool has_sourcetype() const;
  inline void clear_sourcetype();
  static const int kSourceTypeFieldNumber = 7;
  inline ::com::alibaba::otter::canal::protocol::Type sourcetype() const;
  inline void set_sourcetype(::com::alibaba::otter::canal::protocol::Type value);

  // optional string schemaName = 8;
  inline bool has_schemaname() const;
  inline void clear_schemaname();
  static const int kSchemaNameFieldNumber = 8;
  inline const ::std::string& schemaname() const;
  inline void set_schemaname(const ::std::string& value);
  inline void set_schemaname(const char* value);
  inline void set_schemaname(const char* value, size_t size);
  inline ::std::string* mutable_schemaname();
  inline ::std::string* release_schemaname();
  inline void set_allocated_schemaname(::std::string* schemaname);

  // optional string tableName = 9;
  inline bool has_tablename() const;
  inline void clear_tablename();
  static const int kTableNameFieldNumber = 9;
  inline const ::std::string& tablename() const;
  inline void set_tablename(const ::std::string& value);
  inline void set_tablename(const char* value);
  inline void set_tablename(const char* value, size_t size);
  inline ::std::string* mutable_tablename();
  inline ::std::string* release_tablename();
  inline void set_allocated_tablename(::std::string* tablename);

  // optional int64 eventLength = 10;
  inline bool has_eventlength() const;
  inline void clear_eventlength();
  static const int kEventLengthFieldNumber = 10;
  inline ::google::protobuf::int64 eventlength() const;
  inline void set_eventlength(::google::protobuf::int64 value);

  // optional .com.alibaba.otter.canal.protocol.EventType eventType = 11 [default = UPDATE];
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 11;
  inline ::com::alibaba::otter::canal::protocol::EventType eventtype() const;
  inline void set_eventtype(::com::alibaba::otter::canal::protocol::EventType value);

  // repeated .com.alibaba.otter.canal.protocol.Pair props = 12;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 12;
  inline const ::com::alibaba::otter::canal::protocol::Pair& props(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Pair* mutable_props(int index);
  inline ::com::alibaba::otter::canal::protocol::Pair* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
      mutable_props();

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Header)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_logfilename();
  inline void clear_has_logfilename();
  inline void set_has_logfileoffset();
  inline void clear_has_logfileoffset();
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_serverencode();
  inline void clear_has_serverencode();
  inline void set_has_executetime();
  inline void clear_has_executetime();
  inline void set_has_sourcetype();
  inline void clear_has_sourcetype();
  inline void set_has_schemaname();
  inline void clear_has_schemaname();
  inline void set_has_tablename();
  inline void clear_has_tablename();
  inline void set_has_eventlength();
  inline void clear_has_eventlength();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* logfilename_;
  ::google::protobuf::int64 logfileoffset_;
  ::google::protobuf::int64 serverid_;
  ::google::protobuf::int32 version_;
  int sourcetype_;
  ::std::string* serverencode_;
  ::google::protobuf::int64 executetime_;
  ::std::string* schemaname_;
  ::std::string* tablename_;
  ::google::protobuf::int64 eventlength_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair > props_;
  int eventtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static Header* default_instance_;
};
// -------------------------------------------------------------------

class Column : public ::google::protobuf::Message {
 public:
  Column();
  virtual ~Column();

  Column(const Column& from);

  inline Column& operator=(const Column& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Column& default_instance();

  void Swap(Column* other);

  // implements Message ----------------------------------------------

  Column* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Column& from);
  void MergeFrom(const Column& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::int32 index() const;
  inline void set_index(::google::protobuf::int32 value);

  // optional int32 sqlType = 2;
  inline bool has_sqltype() const;
  inline void clear_sqltype();
  static const int kSqlTypeFieldNumber = 2;
  inline ::google::protobuf::int32 sqltype() const;
  inline void set_sqltype(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool isKey = 4;
  inline bool has_iskey() const;
  inline void clear_iskey();
  static const int kIsKeyFieldNumber = 4;
  inline bool iskey() const;
  inline void set_iskey(bool value);

  // optional bool updated = 5;
  inline bool has_updated() const;
  inline void clear_updated();
  static const int kUpdatedFieldNumber = 5;
  inline bool updated() const;
  inline void set_updated(bool value);

  // optional bool isNull = 6 [default = false];
  inline bool has_isnull() const;
  inline void clear_isnull();
  static const int kIsNullFieldNumber = 6;
  inline bool isnull() const;
  inline void set_isnull(bool value);

  // repeated .com.alibaba.otter.canal.protocol.Pair props = 7;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 7;
  inline const ::com::alibaba::otter::canal::protocol::Pair& props(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Pair* mutable_props(int index);
  inline ::com::alibaba::otter::canal::protocol::Pair* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
      mutable_props();

  // optional string value = 8;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 8;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional int32 length = 9;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 9;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // optional string mysqlType = 10;
  inline bool has_mysqltype() const;
  inline void clear_mysqltype();
  static const int kMysqlTypeFieldNumber = 10;
  inline const ::std::string& mysqltype() const;
  inline void set_mysqltype(const ::std::string& value);
  inline void set_mysqltype(const char* value);
  inline void set_mysqltype(const char* value, size_t size);
  inline ::std::string* mutable_mysqltype();
  inline ::std::string* release_mysqltype();
  inline void set_allocated_mysqltype(::std::string* mysqltype);

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Column)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_sqltype();
  inline void clear_has_sqltype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_iskey();
  inline void clear_has_iskey();
  inline void set_has_updated();
  inline void clear_has_updated();
  inline void set_has_isnull();
  inline void clear_has_isnull();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_mysqltype();
  inline void clear_has_mysqltype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 index_;
  ::google::protobuf::int32 sqltype_;
  ::std::string* name_;
  bool iskey_;
  bool updated_;
  bool isnull_;
  ::google::protobuf::int32 length_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair > props_;
  ::std::string* value_;
  ::std::string* mysqltype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static Column* default_instance_;
};
// -------------------------------------------------------------------

class RowData : public ::google::protobuf::Message {
 public:
  RowData();
  virtual ~RowData();

  RowData(const RowData& from);

  inline RowData& operator=(const RowData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RowData& default_instance();

  void Swap(RowData* other);

  // implements Message ----------------------------------------------

  RowData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RowData& from);
  void MergeFrom(const RowData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .com.alibaba.otter.canal.protocol.Column beforeColumns = 1;
  inline int beforecolumns_size() const;
  inline void clear_beforecolumns();
  static const int kBeforeColumnsFieldNumber = 1;
  inline const ::com::alibaba::otter::canal::protocol::Column& beforecolumns(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Column* mutable_beforecolumns(int index);
  inline ::com::alibaba::otter::canal::protocol::Column* add_beforecolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >&
      beforecolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >*
      mutable_beforecolumns();

  // repeated .com.alibaba.otter.canal.protocol.Column afterColumns = 2;
  inline int aftercolumns_size() const;
  inline void clear_aftercolumns();
  static const int kAfterColumnsFieldNumber = 2;
  inline const ::com::alibaba::otter::canal::protocol::Column& aftercolumns(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Column* mutable_aftercolumns(int index);
  inline ::com::alibaba::otter::canal::protocol::Column* add_aftercolumns();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >&
      aftercolumns() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >*
      mutable_aftercolumns();

  // repeated .com.alibaba.otter.canal.protocol.Pair props = 3;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 3;
  inline const ::com::alibaba::otter::canal::protocol::Pair& props(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Pair* mutable_props(int index);
  inline ::com::alibaba::otter::canal::protocol::Pair* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
      mutable_props();

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.RowData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column > beforecolumns_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column > aftercolumns_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair > props_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static RowData* default_instance_;
};
// -------------------------------------------------------------------

class RowChange : public ::google::protobuf::Message {
 public:
  RowChange();
  virtual ~RowChange();

  RowChange(const RowChange& from);

  inline RowChange& operator=(const RowChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RowChange& default_instance();

  void Swap(RowChange* other);

  // implements Message ----------------------------------------------

  RowChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RowChange& from);
  void MergeFrom(const RowChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 tableId = 1;
  inline bool has_tableid() const;
  inline void clear_tableid();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int64 tableid() const;
  inline void set_tableid(::google::protobuf::int64 value);

  // optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 2;
  inline ::com::alibaba::otter::canal::protocol::EventType eventtype() const;
  inline void set_eventtype(::com::alibaba::otter::canal::protocol::EventType value);

  // optional bool isDdl = 10 [default = false];
  inline bool has_isddl() const;
  inline void clear_isddl();
  static const int kIsDdlFieldNumber = 10;
  inline bool isddl() const;
  inline void set_isddl(bool value);

  // optional string sql = 11;
  inline bool has_sql() const;
  inline void clear_sql();
  static const int kSqlFieldNumber = 11;
  inline const ::std::string& sql() const;
  inline void set_sql(const ::std::string& value);
  inline void set_sql(const char* value);
  inline void set_sql(const char* value, size_t size);
  inline ::std::string* mutable_sql();
  inline ::std::string* release_sql();
  inline void set_allocated_sql(::std::string* sql);

  // repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;
  inline int rowdatas_size() const;
  inline void clear_rowdatas();
  static const int kRowDatasFieldNumber = 12;
  inline const ::com::alibaba::otter::canal::protocol::RowData& rowdatas(int index) const;
  inline ::com::alibaba::otter::canal::protocol::RowData* mutable_rowdatas(int index);
  inline ::com::alibaba::otter::canal::protocol::RowData* add_rowdatas();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::RowData >&
      rowdatas() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::RowData >*
      mutable_rowdatas();

  // repeated .com.alibaba.otter.canal.protocol.Pair props = 13;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 13;
  inline const ::com::alibaba::otter::canal::protocol::Pair& props(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Pair* mutable_props(int index);
  inline ::com::alibaba::otter::canal::protocol::Pair* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
      mutable_props();

  // optional string ddlSchemaName = 14;
  inline bool has_ddlschemaname() const;
  inline void clear_ddlschemaname();
  static const int kDdlSchemaNameFieldNumber = 14;
  inline const ::std::string& ddlschemaname() const;
  inline void set_ddlschemaname(const ::std::string& value);
  inline void set_ddlschemaname(const char* value);
  inline void set_ddlschemaname(const char* value, size_t size);
  inline ::std::string* mutable_ddlschemaname();
  inline ::std::string* release_ddlschemaname();
  inline void set_allocated_ddlschemaname(::std::string* ddlschemaname);

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.RowChange)
 private:
  inline void set_has_tableid();
  inline void clear_has_tableid();
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_isddl();
  inline void clear_has_isddl();
  inline void set_has_sql();
  inline void clear_has_sql();
  inline void set_has_ddlschemaname();
  inline void clear_has_ddlschemaname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 tableid_;
  int eventtype_;
  bool isddl_;
  ::std::string* sql_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::RowData > rowdatas_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair > props_;
  ::std::string* ddlschemaname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static RowChange* default_instance_;
};
// -------------------------------------------------------------------

class TransactionBegin : public ::google::protobuf::Message {
 public:
  TransactionBegin();
  virtual ~TransactionBegin();

  TransactionBegin(const TransactionBegin& from);

  inline TransactionBegin& operator=(const TransactionBegin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionBegin& default_instance();

  void Swap(TransactionBegin* other);

  // implements Message ----------------------------------------------

  TransactionBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionBegin& from);
  void MergeFrom(const TransactionBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 executeTime = 1;
  inline bool has_executetime() const;
  inline void clear_executetime();
  static const int kExecuteTimeFieldNumber = 1;
  inline ::google::protobuf::int64 executetime() const;
  inline void set_executetime(::google::protobuf::int64 value);

  // optional string transactionId = 2;
  inline bool has_transactionid() const;
  inline void clear_transactionid();
  static const int kTransactionIdFieldNumber = 2;
  inline const ::std::string& transactionid() const;
  inline void set_transactionid(const ::std::string& value);
  inline void set_transactionid(const char* value);
  inline void set_transactionid(const char* value, size_t size);
  inline ::std::string* mutable_transactionid();
  inline ::std::string* release_transactionid();
  inline void set_allocated_transactionid(::std::string* transactionid);

  // repeated .com.alibaba.otter.canal.protocol.Pair props = 3;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 3;
  inline const ::com::alibaba::otter::canal::protocol::Pair& props(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Pair* mutable_props(int index);
  inline ::com::alibaba::otter::canal::protocol::Pair* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
      mutable_props();

  // optional int64 threadId = 4;
  inline bool has_threadid() const;
  inline void clear_threadid();
  static const int kThreadIdFieldNumber = 4;
  inline ::google::protobuf::int64 threadid() const;
  inline void set_threadid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.TransactionBegin)
 private:
  inline void set_has_executetime();
  inline void clear_has_executetime();
  inline void set_has_transactionid();
  inline void clear_has_transactionid();
  inline void set_has_threadid();
  inline void clear_has_threadid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 executetime_;
  ::std::string* transactionid_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair > props_;
  ::google::protobuf::int64 threadid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static TransactionBegin* default_instance_;
};
// -------------------------------------------------------------------

class TransactionEnd : public ::google::protobuf::Message {
 public:
  TransactionEnd();
  virtual ~TransactionEnd();

  TransactionEnd(const TransactionEnd& from);

  inline TransactionEnd& operator=(const TransactionEnd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransactionEnd& default_instance();

  void Swap(TransactionEnd* other);

  // implements Message ----------------------------------------------

  TransactionEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransactionEnd& from);
  void MergeFrom(const TransactionEnd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 executeTime = 1;
  inline bool has_executetime() const;
  inline void clear_executetime();
  static const int kExecuteTimeFieldNumber = 1;
  inline ::google::protobuf::int64 executetime() const;
  inline void set_executetime(::google::protobuf::int64 value);

  // optional string transactionId = 2;
  inline bool has_transactionid() const;
  inline void clear_transactionid();
  static const int kTransactionIdFieldNumber = 2;
  inline const ::std::string& transactionid() const;
  inline void set_transactionid(const ::std::string& value);
  inline void set_transactionid(const char* value);
  inline void set_transactionid(const char* value, size_t size);
  inline ::std::string* mutable_transactionid();
  inline ::std::string* release_transactionid();
  inline void set_allocated_transactionid(::std::string* transactionid);

  // repeated .com.alibaba.otter.canal.protocol.Pair props = 3;
  inline int props_size() const;
  inline void clear_props();
  static const int kPropsFieldNumber = 3;
  inline const ::com::alibaba::otter::canal::protocol::Pair& props(int index) const;
  inline ::com::alibaba::otter::canal::protocol::Pair* mutable_props(int index);
  inline ::com::alibaba::otter::canal::protocol::Pair* add_props();
  inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
      props() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
      mutable_props();

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.TransactionEnd)
 private:
  inline void set_has_executetime();
  inline void clear_has_executetime();
  inline void set_has_transactionid();
  inline void clear_has_transactionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 executetime_;
  ::std::string* transactionid_;
  ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair > props_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static TransactionEnd* default_instance_;
};
// -------------------------------------------------------------------

class Pair : public ::google::protobuf::Message {
 public:
  Pair();
  virtual ~Pair();

  Pair(const Pair& from);

  inline Pair& operator=(const Pair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pair& default_instance();

  void Swap(Pair* other);

  // implements Message ----------------------------------------------

  Pair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pair& from);
  void MergeFrom(const Pair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.alibaba.otter.canal.protocol.Pair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_EntryProtocol_2eproto();
  friend void protobuf_AssignDesc_EntryProtocol_2eproto();
  friend void protobuf_ShutdownFile_EntryProtocol_2eproto();

  void InitAsDefaultInstance();
  static Pair* default_instance_;
};
// ===================================================================


// ===================================================================

// Entry

// optional .com.alibaba.otter.canal.protocol.Header header = 1;
inline bool Entry::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Entry::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Entry::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Entry::clear_header() {
  if (header_ != NULL) header_->::com::alibaba::otter::canal::protocol::Header::Clear();
  clear_has_header();
}
inline const ::com::alibaba::otter::canal::protocol::Header& Entry::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::com::alibaba::otter::canal::protocol::Header* Entry::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::com::alibaba::otter::canal::protocol::Header;
  return header_;
}
inline ::com::alibaba::otter::canal::protocol::Header* Entry::release_header() {
  clear_has_header();
  ::com::alibaba::otter::canal::protocol::Header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void Entry::set_allocated_header(::com::alibaba::otter::canal::protocol::Header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .com.alibaba.otter.canal.protocol.EntryType entryType = 2 [default = ROWDATA];
inline bool Entry::has_entrytype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Entry::set_has_entrytype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Entry::clear_has_entrytype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Entry::clear_entrytype() {
  entrytype_ = 2;
  clear_has_entrytype();
}
inline ::com::alibaba::otter::canal::protocol::EntryType Entry::entrytype() const {
  return static_cast< ::com::alibaba::otter::canal::protocol::EntryType >(entrytype_);
}
inline void Entry::set_entrytype(::com::alibaba::otter::canal::protocol::EntryType value) {
  assert(::com::alibaba::otter::canal::protocol::EntryType_IsValid(value));
  set_has_entrytype();
  entrytype_ = value;
}

// optional bytes storeValue = 3;
inline bool Entry::has_storevalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Entry::set_has_storevalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Entry::clear_has_storevalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Entry::clear_storevalue() {
  if (storevalue_ != &::google::protobuf::internal::kEmptyString) {
    storevalue_->clear();
  }
  clear_has_storevalue();
}
inline const ::std::string& Entry::storevalue() const {
  return *storevalue_;
}
inline void Entry::set_storevalue(const ::std::string& value) {
  set_has_storevalue();
  if (storevalue_ == &::google::protobuf::internal::kEmptyString) {
    storevalue_ = new ::std::string;
  }
  storevalue_->assign(value);
}
inline void Entry::set_storevalue(const char* value) {
  set_has_storevalue();
  if (storevalue_ == &::google::protobuf::internal::kEmptyString) {
    storevalue_ = new ::std::string;
  }
  storevalue_->assign(value);
}
inline void Entry::set_storevalue(const void* value, size_t size) {
  set_has_storevalue();
  if (storevalue_ == &::google::protobuf::internal::kEmptyString) {
    storevalue_ = new ::std::string;
  }
  storevalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Entry::mutable_storevalue() {
  set_has_storevalue();
  if (storevalue_ == &::google::protobuf::internal::kEmptyString) {
    storevalue_ = new ::std::string;
  }
  return storevalue_;
}
inline ::std::string* Entry::release_storevalue() {
  clear_has_storevalue();
  if (storevalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = storevalue_;
    storevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Entry::set_allocated_storevalue(::std::string* storevalue) {
  if (storevalue_ != &::google::protobuf::internal::kEmptyString) {
    delete storevalue_;
  }
  if (storevalue) {
    set_has_storevalue();
    storevalue_ = storevalue;
  } else {
    clear_has_storevalue();
    storevalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Header

// optional int32 version = 1 [default = 1];
inline bool Header::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Header::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Header::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Header::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::google::protobuf::int32 Header::version() const {
  return version_;
}
inline void Header::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
}

// optional string logfileName = 2;
inline bool Header::has_logfilename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Header::set_has_logfilename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Header::clear_has_logfilename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Header::clear_logfilename() {
  if (logfilename_ != &::google::protobuf::internal::kEmptyString) {
    logfilename_->clear();
  }
  clear_has_logfilename();
}
inline const ::std::string& Header::logfilename() const {
  return *logfilename_;
}
inline void Header::set_logfilename(const ::std::string& value) {
  set_has_logfilename();
  if (logfilename_ == &::google::protobuf::internal::kEmptyString) {
    logfilename_ = new ::std::string;
  }
  logfilename_->assign(value);
}
inline void Header::set_logfilename(const char* value) {
  set_has_logfilename();
  if (logfilename_ == &::google::protobuf::internal::kEmptyString) {
    logfilename_ = new ::std::string;
  }
  logfilename_->assign(value);
}
inline void Header::set_logfilename(const char* value, size_t size) {
  set_has_logfilename();
  if (logfilename_ == &::google::protobuf::internal::kEmptyString) {
    logfilename_ = new ::std::string;
  }
  logfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_logfilename() {
  set_has_logfilename();
  if (logfilename_ == &::google::protobuf::internal::kEmptyString) {
    logfilename_ = new ::std::string;
  }
  return logfilename_;
}
inline ::std::string* Header::release_logfilename() {
  clear_has_logfilename();
  if (logfilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logfilename_;
    logfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_logfilename(::std::string* logfilename) {
  if (logfilename_ != &::google::protobuf::internal::kEmptyString) {
    delete logfilename_;
  }
  if (logfilename) {
    set_has_logfilename();
    logfilename_ = logfilename;
  } else {
    clear_has_logfilename();
    logfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 logfileOffset = 3;
inline bool Header::has_logfileoffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Header::set_has_logfileoffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Header::clear_has_logfileoffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Header::clear_logfileoffset() {
  logfileoffset_ = GOOGLE_LONGLONG(0);
  clear_has_logfileoffset();
}
inline ::google::protobuf::int64 Header::logfileoffset() const {
  return logfileoffset_;
}
inline void Header::set_logfileoffset(::google::protobuf::int64 value) {
  set_has_logfileoffset();
  logfileoffset_ = value;
}

// optional int64 serverId = 4;
inline bool Header::has_serverid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Header::set_has_serverid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Header::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Header::clear_serverid() {
  serverid_ = GOOGLE_LONGLONG(0);
  clear_has_serverid();
}
inline ::google::protobuf::int64 Header::serverid() const {
  return serverid_;
}
inline void Header::set_serverid(::google::protobuf::int64 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string serverenCode = 5;
inline bool Header::has_serverencode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Header::set_has_serverencode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Header::clear_has_serverencode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Header::clear_serverencode() {
  if (serverencode_ != &::google::protobuf::internal::kEmptyString) {
    serverencode_->clear();
  }
  clear_has_serverencode();
}
inline const ::std::string& Header::serverencode() const {
  return *serverencode_;
}
inline void Header::set_serverencode(const ::std::string& value) {
  set_has_serverencode();
  if (serverencode_ == &::google::protobuf::internal::kEmptyString) {
    serverencode_ = new ::std::string;
  }
  serverencode_->assign(value);
}
inline void Header::set_serverencode(const char* value) {
  set_has_serverencode();
  if (serverencode_ == &::google::protobuf::internal::kEmptyString) {
    serverencode_ = new ::std::string;
  }
  serverencode_->assign(value);
}
inline void Header::set_serverencode(const char* value, size_t size) {
  set_has_serverencode();
  if (serverencode_ == &::google::protobuf::internal::kEmptyString) {
    serverencode_ = new ::std::string;
  }
  serverencode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_serverencode() {
  set_has_serverencode();
  if (serverencode_ == &::google::protobuf::internal::kEmptyString) {
    serverencode_ = new ::std::string;
  }
  return serverencode_;
}
inline ::std::string* Header::release_serverencode() {
  clear_has_serverencode();
  if (serverencode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverencode_;
    serverencode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_serverencode(::std::string* serverencode) {
  if (serverencode_ != &::google::protobuf::internal::kEmptyString) {
    delete serverencode_;
  }
  if (serverencode) {
    set_has_serverencode();
    serverencode_ = serverencode;
  } else {
    clear_has_serverencode();
    serverencode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 executeTime = 6;
inline bool Header::has_executetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Header::set_has_executetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Header::clear_has_executetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Header::clear_executetime() {
  executetime_ = GOOGLE_LONGLONG(0);
  clear_has_executetime();
}
inline ::google::protobuf::int64 Header::executetime() const {
  return executetime_;
}
inline void Header::set_executetime(::google::protobuf::int64 value) {
  set_has_executetime();
  executetime_ = value;
}

// optional .com.alibaba.otter.canal.protocol.Type sourceType = 7 [default = MYSQL];
inline bool Header::has_sourcetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Header::set_has_sourcetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Header::clear_has_sourcetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Header::clear_sourcetype() {
  sourcetype_ = 2;
  clear_has_sourcetype();
}
inline ::com::alibaba::otter::canal::protocol::Type Header::sourcetype() const {
  return static_cast< ::com::alibaba::otter::canal::protocol::Type >(sourcetype_);
}
inline void Header::set_sourcetype(::com::alibaba::otter::canal::protocol::Type value) {
  assert(::com::alibaba::otter::canal::protocol::Type_IsValid(value));
  set_has_sourcetype();
  sourcetype_ = value;
}

// optional string schemaName = 8;
inline bool Header::has_schemaname() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Header::set_has_schemaname() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Header::clear_has_schemaname() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Header::clear_schemaname() {
  if (schemaname_ != &::google::protobuf::internal::kEmptyString) {
    schemaname_->clear();
  }
  clear_has_schemaname();
}
inline const ::std::string& Header::schemaname() const {
  return *schemaname_;
}
inline void Header::set_schemaname(const ::std::string& value) {
  set_has_schemaname();
  if (schemaname_ == &::google::protobuf::internal::kEmptyString) {
    schemaname_ = new ::std::string;
  }
  schemaname_->assign(value);
}
inline void Header::set_schemaname(const char* value) {
  set_has_schemaname();
  if (schemaname_ == &::google::protobuf::internal::kEmptyString) {
    schemaname_ = new ::std::string;
  }
  schemaname_->assign(value);
}
inline void Header::set_schemaname(const char* value, size_t size) {
  set_has_schemaname();
  if (schemaname_ == &::google::protobuf::internal::kEmptyString) {
    schemaname_ = new ::std::string;
  }
  schemaname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_schemaname() {
  set_has_schemaname();
  if (schemaname_ == &::google::protobuf::internal::kEmptyString) {
    schemaname_ = new ::std::string;
  }
  return schemaname_;
}
inline ::std::string* Header::release_schemaname() {
  clear_has_schemaname();
  if (schemaname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = schemaname_;
    schemaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_schemaname(::std::string* schemaname) {
  if (schemaname_ != &::google::protobuf::internal::kEmptyString) {
    delete schemaname_;
  }
  if (schemaname) {
    set_has_schemaname();
    schemaname_ = schemaname;
  } else {
    clear_has_schemaname();
    schemaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tableName = 9;
inline bool Header::has_tablename() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Header::set_has_tablename() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Header::clear_has_tablename() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Header::clear_tablename() {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    tablename_->clear();
  }
  clear_has_tablename();
}
inline const ::std::string& Header::tablename() const {
  return *tablename_;
}
inline void Header::set_tablename(const ::std::string& value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void Header::set_tablename(const char* value) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(value);
}
inline void Header::set_tablename(const char* value, size_t size) {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  tablename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Header::mutable_tablename() {
  set_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    tablename_ = new ::std::string;
  }
  return tablename_;
}
inline ::std::string* Header::release_tablename() {
  clear_has_tablename();
  if (tablename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablename_;
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Header::set_allocated_tablename(::std::string* tablename) {
  if (tablename_ != &::google::protobuf::internal::kEmptyString) {
    delete tablename_;
  }
  if (tablename) {
    set_has_tablename();
    tablename_ = tablename;
  } else {
    clear_has_tablename();
    tablename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 eventLength = 10;
inline bool Header::has_eventlength() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Header::set_has_eventlength() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Header::clear_has_eventlength() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Header::clear_eventlength() {
  eventlength_ = GOOGLE_LONGLONG(0);
  clear_has_eventlength();
}
inline ::google::protobuf::int64 Header::eventlength() const {
  return eventlength_;
}
inline void Header::set_eventlength(::google::protobuf::int64 value) {
  set_has_eventlength();
  eventlength_ = value;
}

// optional .com.alibaba.otter.canal.protocol.EventType eventType = 11 [default = UPDATE];
inline bool Header::has_eventtype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Header::set_has_eventtype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Header::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Header::clear_eventtype() {
  eventtype_ = 2;
  clear_has_eventtype();
}
inline ::com::alibaba::otter::canal::protocol::EventType Header::eventtype() const {
  return static_cast< ::com::alibaba::otter::canal::protocol::EventType >(eventtype_);
}
inline void Header::set_eventtype(::com::alibaba::otter::canal::protocol::EventType value) {
  assert(::com::alibaba::otter::canal::protocol::EventType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// repeated .com.alibaba.otter.canal.protocol.Pair props = 12;
inline int Header::props_size() const {
  return props_.size();
}
inline void Header::clear_props() {
  props_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Pair& Header::props(int index) const {
  return props_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* Header::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* Header::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
Header::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
Header::mutable_props() {
  return &props_;
}

// -------------------------------------------------------------------

// Column

// optional int32 index = 1;
inline bool Column::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Column::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Column::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Column::clear_index() {
  index_ = 0;
  clear_has_index();
}
inline ::google::protobuf::int32 Column::index() const {
  return index_;
}
inline void Column::set_index(::google::protobuf::int32 value) {
  set_has_index();
  index_ = value;
}

// optional int32 sqlType = 2;
inline bool Column::has_sqltype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Column::set_has_sqltype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Column::clear_has_sqltype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Column::clear_sqltype() {
  sqltype_ = 0;
  clear_has_sqltype();
}
inline ::google::protobuf::int32 Column::sqltype() const {
  return sqltype_;
}
inline void Column::set_sqltype(::google::protobuf::int32 value) {
  set_has_sqltype();
  sqltype_ = value;
}

// optional string name = 3;
inline bool Column::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Column::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Column::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Column::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Column::name() const {
  return *name_;
}
inline void Column::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Column::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Column::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Column::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Column::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isKey = 4;
inline bool Column::has_iskey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Column::set_has_iskey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Column::clear_has_iskey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Column::clear_iskey() {
  iskey_ = false;
  clear_has_iskey();
}
inline bool Column::iskey() const {
  return iskey_;
}
inline void Column::set_iskey(bool value) {
  set_has_iskey();
  iskey_ = value;
}

// optional bool updated = 5;
inline bool Column::has_updated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Column::set_has_updated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Column::clear_has_updated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Column::clear_updated() {
  updated_ = false;
  clear_has_updated();
}
inline bool Column::updated() const {
  return updated_;
}
inline void Column::set_updated(bool value) {
  set_has_updated();
  updated_ = value;
}

// optional bool isNull = 6 [default = false];
inline bool Column::has_isnull() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Column::set_has_isnull() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Column::clear_has_isnull() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Column::clear_isnull() {
  isnull_ = false;
  clear_has_isnull();
}
inline bool Column::isnull() const {
  return isnull_;
}
inline void Column::set_isnull(bool value) {
  set_has_isnull();
  isnull_ = value;
}

// repeated .com.alibaba.otter.canal.protocol.Pair props = 7;
inline int Column::props_size() const {
  return props_.size();
}
inline void Column::clear_props() {
  props_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Pair& Column::props(int index) const {
  return props_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* Column::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* Column::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
Column::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
Column::mutable_props() {
  return &props_;
}

// optional string value = 8;
inline bool Column::has_value() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Column::set_has_value() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Column::clear_has_value() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Column::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Column::value() const {
  return *value_;
}
inline void Column::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Column::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Column::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Column::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Column::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 length = 9;
inline bool Column::has_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Column::set_has_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Column::clear_has_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Column::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 Column::length() const {
  return length_;
}
inline void Column::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// optional string mysqlType = 10;
inline bool Column::has_mysqltype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Column::set_has_mysqltype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Column::clear_has_mysqltype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Column::clear_mysqltype() {
  if (mysqltype_ != &::google::protobuf::internal::kEmptyString) {
    mysqltype_->clear();
  }
  clear_has_mysqltype();
}
inline const ::std::string& Column::mysqltype() const {
  return *mysqltype_;
}
inline void Column::set_mysqltype(const ::std::string& value) {
  set_has_mysqltype();
  if (mysqltype_ == &::google::protobuf::internal::kEmptyString) {
    mysqltype_ = new ::std::string;
  }
  mysqltype_->assign(value);
}
inline void Column::set_mysqltype(const char* value) {
  set_has_mysqltype();
  if (mysqltype_ == &::google::protobuf::internal::kEmptyString) {
    mysqltype_ = new ::std::string;
  }
  mysqltype_->assign(value);
}
inline void Column::set_mysqltype(const char* value, size_t size) {
  set_has_mysqltype();
  if (mysqltype_ == &::google::protobuf::internal::kEmptyString) {
    mysqltype_ = new ::std::string;
  }
  mysqltype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Column::mutable_mysqltype() {
  set_has_mysqltype();
  if (mysqltype_ == &::google::protobuf::internal::kEmptyString) {
    mysqltype_ = new ::std::string;
  }
  return mysqltype_;
}
inline ::std::string* Column::release_mysqltype() {
  clear_has_mysqltype();
  if (mysqltype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mysqltype_;
    mysqltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Column::set_allocated_mysqltype(::std::string* mysqltype) {
  if (mysqltype_ != &::google::protobuf::internal::kEmptyString) {
    delete mysqltype_;
  }
  if (mysqltype) {
    set_has_mysqltype();
    mysqltype_ = mysqltype;
  } else {
    clear_has_mysqltype();
    mysqltype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RowData

// repeated .com.alibaba.otter.canal.protocol.Column beforeColumns = 1;
inline int RowData::beforecolumns_size() const {
  return beforecolumns_.size();
}
inline void RowData::clear_beforecolumns() {
  beforecolumns_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Column& RowData::beforecolumns(int index) const {
  return beforecolumns_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Column* RowData::mutable_beforecolumns(int index) {
  return beforecolumns_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Column* RowData::add_beforecolumns() {
  return beforecolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >&
RowData::beforecolumns() const {
  return beforecolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >*
RowData::mutable_beforecolumns() {
  return &beforecolumns_;
}

// repeated .com.alibaba.otter.canal.protocol.Column afterColumns = 2;
inline int RowData::aftercolumns_size() const {
  return aftercolumns_.size();
}
inline void RowData::clear_aftercolumns() {
  aftercolumns_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Column& RowData::aftercolumns(int index) const {
  return aftercolumns_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Column* RowData::mutable_aftercolumns(int index) {
  return aftercolumns_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Column* RowData::add_aftercolumns() {
  return aftercolumns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >&
RowData::aftercolumns() const {
  return aftercolumns_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Column >*
RowData::mutable_aftercolumns() {
  return &aftercolumns_;
}

// repeated .com.alibaba.otter.canal.protocol.Pair props = 3;
inline int RowData::props_size() const {
  return props_.size();
}
inline void RowData::clear_props() {
  props_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Pair& RowData::props(int index) const {
  return props_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* RowData::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* RowData::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
RowData::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
RowData::mutable_props() {
  return &props_;
}

// -------------------------------------------------------------------

// RowChange

// optional int64 tableId = 1;
inline bool RowChange::has_tableid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RowChange::set_has_tableid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RowChange::clear_has_tableid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RowChange::clear_tableid() {
  tableid_ = GOOGLE_LONGLONG(0);
  clear_has_tableid();
}
inline ::google::protobuf::int64 RowChange::tableid() const {
  return tableid_;
}
inline void RowChange::set_tableid(::google::protobuf::int64 value) {
  set_has_tableid();
  tableid_ = value;
}

// optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];
inline bool RowChange::has_eventtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RowChange::set_has_eventtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RowChange::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RowChange::clear_eventtype() {
  eventtype_ = 2;
  clear_has_eventtype();
}
inline ::com::alibaba::otter::canal::protocol::EventType RowChange::eventtype() const {
  return static_cast< ::com::alibaba::otter::canal::protocol::EventType >(eventtype_);
}
inline void RowChange::set_eventtype(::com::alibaba::otter::canal::protocol::EventType value) {
  assert(::com::alibaba::otter::canal::protocol::EventType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
}

// optional bool isDdl = 10 [default = false];
inline bool RowChange::has_isddl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RowChange::set_has_isddl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RowChange::clear_has_isddl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RowChange::clear_isddl() {
  isddl_ = false;
  clear_has_isddl();
}
inline bool RowChange::isddl() const {
  return isddl_;
}
inline void RowChange::set_isddl(bool value) {
  set_has_isddl();
  isddl_ = value;
}

// optional string sql = 11;
inline bool RowChange::has_sql() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RowChange::set_has_sql() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RowChange::clear_has_sql() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RowChange::clear_sql() {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    sql_->clear();
  }
  clear_has_sql();
}
inline const ::std::string& RowChange::sql() const {
  return *sql_;
}
inline void RowChange::set_sql(const ::std::string& value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void RowChange::set_sql(const char* value) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(value);
}
inline void RowChange::set_sql(const char* value, size_t size) {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  sql_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RowChange::mutable_sql() {
  set_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    sql_ = new ::std::string;
  }
  return sql_;
}
inline ::std::string* RowChange::release_sql() {
  clear_has_sql();
  if (sql_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sql_;
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RowChange::set_allocated_sql(::std::string* sql) {
  if (sql_ != &::google::protobuf::internal::kEmptyString) {
    delete sql_;
  }
  if (sql) {
    set_has_sql();
    sql_ = sql;
  } else {
    clear_has_sql();
    sql_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;
inline int RowChange::rowdatas_size() const {
  return rowdatas_.size();
}
inline void RowChange::clear_rowdatas() {
  rowdatas_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::RowData& RowChange::rowdatas(int index) const {
  return rowdatas_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::RowData* RowChange::mutable_rowdatas(int index) {
  return rowdatas_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::RowData* RowChange::add_rowdatas() {
  return rowdatas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::RowData >&
RowChange::rowdatas() const {
  return rowdatas_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::RowData >*
RowChange::mutable_rowdatas() {
  return &rowdatas_;
}

// repeated .com.alibaba.otter.canal.protocol.Pair props = 13;
inline int RowChange::props_size() const {
  return props_.size();
}
inline void RowChange::clear_props() {
  props_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Pair& RowChange::props(int index) const {
  return props_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* RowChange::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* RowChange::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
RowChange::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
RowChange::mutable_props() {
  return &props_;
}

// optional string ddlSchemaName = 14;
inline bool RowChange::has_ddlschemaname() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RowChange::set_has_ddlschemaname() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RowChange::clear_has_ddlschemaname() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RowChange::clear_ddlschemaname() {
  if (ddlschemaname_ != &::google::protobuf::internal::kEmptyString) {
    ddlschemaname_->clear();
  }
  clear_has_ddlschemaname();
}
inline const ::std::string& RowChange::ddlschemaname() const {
  return *ddlschemaname_;
}
inline void RowChange::set_ddlschemaname(const ::std::string& value) {
  set_has_ddlschemaname();
  if (ddlschemaname_ == &::google::protobuf::internal::kEmptyString) {
    ddlschemaname_ = new ::std::string;
  }
  ddlschemaname_->assign(value);
}
inline void RowChange::set_ddlschemaname(const char* value) {
  set_has_ddlschemaname();
  if (ddlschemaname_ == &::google::protobuf::internal::kEmptyString) {
    ddlschemaname_ = new ::std::string;
  }
  ddlschemaname_->assign(value);
}
inline void RowChange::set_ddlschemaname(const char* value, size_t size) {
  set_has_ddlschemaname();
  if (ddlschemaname_ == &::google::protobuf::internal::kEmptyString) {
    ddlschemaname_ = new ::std::string;
  }
  ddlschemaname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RowChange::mutable_ddlschemaname() {
  set_has_ddlschemaname();
  if (ddlschemaname_ == &::google::protobuf::internal::kEmptyString) {
    ddlschemaname_ = new ::std::string;
  }
  return ddlschemaname_;
}
inline ::std::string* RowChange::release_ddlschemaname() {
  clear_has_ddlschemaname();
  if (ddlschemaname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ddlschemaname_;
    ddlschemaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RowChange::set_allocated_ddlschemaname(::std::string* ddlschemaname) {
  if (ddlschemaname_ != &::google::protobuf::internal::kEmptyString) {
    delete ddlschemaname_;
  }
  if (ddlschemaname) {
    set_has_ddlschemaname();
    ddlschemaname_ = ddlschemaname;
  } else {
    clear_has_ddlschemaname();
    ddlschemaname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TransactionBegin

// optional int64 executeTime = 1;
inline bool TransactionBegin::has_executetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionBegin::set_has_executetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionBegin::clear_has_executetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionBegin::clear_executetime() {
  executetime_ = GOOGLE_LONGLONG(0);
  clear_has_executetime();
}
inline ::google::protobuf::int64 TransactionBegin::executetime() const {
  return executetime_;
}
inline void TransactionBegin::set_executetime(::google::protobuf::int64 value) {
  set_has_executetime();
  executetime_ = value;
}

// optional string transactionId = 2;
inline bool TransactionBegin::has_transactionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionBegin::set_has_transactionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionBegin::clear_has_transactionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionBegin::clear_transactionid() {
  if (transactionid_ != &::google::protobuf::internal::kEmptyString) {
    transactionid_->clear();
  }
  clear_has_transactionid();
}
inline const ::std::string& TransactionBegin::transactionid() const {
  return *transactionid_;
}
inline void TransactionBegin::set_transactionid(const ::std::string& value) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(value);
}
inline void TransactionBegin::set_transactionid(const char* value) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(value);
}
inline void TransactionBegin::set_transactionid(const char* value, size_t size) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionBegin::mutable_transactionid() {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  return transactionid_;
}
inline ::std::string* TransactionBegin::release_transactionid() {
  clear_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transactionid_;
    transactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransactionBegin::set_allocated_transactionid(::std::string* transactionid) {
  if (transactionid_ != &::google::protobuf::internal::kEmptyString) {
    delete transactionid_;
  }
  if (transactionid) {
    set_has_transactionid();
    transactionid_ = transactionid;
  } else {
    clear_has_transactionid();
    transactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.alibaba.otter.canal.protocol.Pair props = 3;
inline int TransactionBegin::props_size() const {
  return props_.size();
}
inline void TransactionBegin::clear_props() {
  props_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Pair& TransactionBegin::props(int index) const {
  return props_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* TransactionBegin::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* TransactionBegin::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
TransactionBegin::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
TransactionBegin::mutable_props() {
  return &props_;
}

// optional int64 threadId = 4;
inline bool TransactionBegin::has_threadid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransactionBegin::set_has_threadid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransactionBegin::clear_has_threadid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransactionBegin::clear_threadid() {
  threadid_ = GOOGLE_LONGLONG(0);
  clear_has_threadid();
}
inline ::google::protobuf::int64 TransactionBegin::threadid() const {
  return threadid_;
}
inline void TransactionBegin::set_threadid(::google::protobuf::int64 value) {
  set_has_threadid();
  threadid_ = value;
}

// -------------------------------------------------------------------

// TransactionEnd

// optional int64 executeTime = 1;
inline bool TransactionEnd::has_executetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransactionEnd::set_has_executetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransactionEnd::clear_has_executetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransactionEnd::clear_executetime() {
  executetime_ = GOOGLE_LONGLONG(0);
  clear_has_executetime();
}
inline ::google::protobuf::int64 TransactionEnd::executetime() const {
  return executetime_;
}
inline void TransactionEnd::set_executetime(::google::protobuf::int64 value) {
  set_has_executetime();
  executetime_ = value;
}

// optional string transactionId = 2;
inline bool TransactionEnd::has_transactionid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransactionEnd::set_has_transactionid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransactionEnd::clear_has_transactionid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransactionEnd::clear_transactionid() {
  if (transactionid_ != &::google::protobuf::internal::kEmptyString) {
    transactionid_->clear();
  }
  clear_has_transactionid();
}
inline const ::std::string& TransactionEnd::transactionid() const {
  return *transactionid_;
}
inline void TransactionEnd::set_transactionid(const ::std::string& value) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(value);
}
inline void TransactionEnd::set_transactionid(const char* value) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(value);
}
inline void TransactionEnd::set_transactionid(const char* value, size_t size) {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  transactionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TransactionEnd::mutable_transactionid() {
  set_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    transactionid_ = new ::std::string;
  }
  return transactionid_;
}
inline ::std::string* TransactionEnd::release_transactionid() {
  clear_has_transactionid();
  if (transactionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = transactionid_;
    transactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransactionEnd::set_allocated_transactionid(::std::string* transactionid) {
  if (transactionid_ != &::google::protobuf::internal::kEmptyString) {
    delete transactionid_;
  }
  if (transactionid) {
    set_has_transactionid();
    transactionid_ = transactionid;
  } else {
    clear_has_transactionid();
    transactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .com.alibaba.otter.canal.protocol.Pair props = 3;
inline int TransactionEnd::props_size() const {
  return props_.size();
}
inline void TransactionEnd::clear_props() {
  props_.Clear();
}
inline const ::com::alibaba::otter::canal::protocol::Pair& TransactionEnd::props(int index) const {
  return props_.Get(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* TransactionEnd::mutable_props(int index) {
  return props_.Mutable(index);
}
inline ::com::alibaba::otter::canal::protocol::Pair* TransactionEnd::add_props() {
  return props_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >&
TransactionEnd::props() const {
  return props_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::alibaba::otter::canal::protocol::Pair >*
TransactionEnd::mutable_props() {
  return &props_;
}

// -------------------------------------------------------------------

// Pair

// optional string key = 1;
inline bool Pair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Pair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Pair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Pair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& Pair::key() const {
  return *key_;
}
inline void Pair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Pair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Pair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* Pair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Pair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool Pair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Pair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Pair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Pair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Pair::value() const {
  return *value_;
}
inline void Pair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Pair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Pair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Pair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Pair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Pair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace canal
}  // namespace otter
}  // namespace alibaba
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::alibaba::otter::canal::protocol::EntryType>() {
  return ::com::alibaba::otter::canal::protocol::EntryType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::alibaba::otter::canal::protocol::EventType>() {
  return ::com::alibaba::otter::canal::protocol::EventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::alibaba::otter::canal::protocol::Type>() {
  return ::com::alibaba::otter::canal::protocol::Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_EntryProtocol_2eproto__INCLUDED
